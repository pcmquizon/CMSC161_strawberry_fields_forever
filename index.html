
<!doctype html>
<html lang="en">
<head>
	<title>CMSC 161 Mini Project</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body>

	<div style="visibility: hidden;">
		<audio controls loop preload="auto" autoplay>
			<source src="audio/The_Beatles-Strawberry_Fields_Forever.mp3" type="audio/mpeg">
			Your browser does not support the audio element.
		</audio>
	</div>

	<script src="js/Three.js"></script>
	<script src="js/Projector.js"></script>
	<script src="js/CanvasRenderer.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/Stats.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/THREEx.KeyboardState.js"></script>
	<script src="js/THREEx.FullScreen.js"></script>
	<script src="js/THREEx.WindowResize.js"></script>
	<script src="js/Bird.js"></script>
	<script src="js/Boid.js"></script>
	<script src="js/stats.min.js"></script>

	<!-- jQuery code to display an information button and box when clicked. -->
	<script src="js/jquery-1.9.1.js"></script>
	<script src="js/jquery-ui.js"></script>
	<link rel=stylesheet href="css/jquery-ui.css" />
	<link rel=stylesheet href="css/info.css"/>
	<script src="js/info.js"></script>
	
	<div id="infoButton"></div>
	<div id="infoBox" title="Demo Information">
		Movement controls: <br/>
		<ul>
		<li>W/S: Translate Forward/Backward
		<li>A/D: Rotate Left/Right
		<li>Q/E: Translate Left/Right
		<li>R/F: Rotate Up/Down
		<li>Arrow keys: Translate (global directions)
		<li>Z: Reset position and rotation.
		</ul>
	</div>
	<!-- ------------------------------------------------------------ -->

	<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
	
	<script>
	// MAIN

	// standard global variables
	var onRenderFcts= [];
	var container, scene, camera, renderer, controls, stats;
	var boid, boids, birds, bird, Bird;
	var keyboard = new THREEx.KeyboardState();
	var clock = new THREE.Clock();

	// custom global variables
	var Strawberry1;
	var Strawberry2;
	var AppleG;
	var Watermelon;
	var ColoredCube;
	var Dice;

	SCREEN_HEIGHT = window.innerHeight;
	SCREEN_WIDTH = window.innerWidth
	SCREEN_WIDTH_HALF = SCREEN_WIDTH  / 2,
	SCREEN_HEIGHT_HALF = SCREEN_HEIGHT / 2;

	init();
	animate();

	// FUNCTIONS 		
	function init() 
	{
		// SCENE
		scene = new THREE.Scene();

		//birds
		birds = [];
		boids = [];
		var z = 400;
		for ( var i = 0; i < 500; i ++ ) {

			boid = boids[ i ] = new Boid();
			boid.position.x = Math.random() * z - (z/2);
			boid.position.y = Math.random() * z - (z/2);
			boid.position.z = Math.random() * z - (z/2);
			boid.velocity.x = Math.random() * 2 - 1;
			boid.velocity.y = Math.random() * 2 - 1;
			boid.velocity.z = Math.random() * 2 - 1;
			boid.setAvoidWalls( true );
			boid.setWorldSize( 800, 800, z );

			bird = birds[ i ] = new THREE.Mesh( new Bird(), new THREE.MeshBasicMaterial( { color:Math.random() * 0xffffff, side: THREE.DoubleSide } ) );
			bird.phase = Math.floor( Math.random() * 62.83 );
			scene.add( bird );

			// bird.castShadow = true;
			// bird.receiveShadow = false;
		}

		// CAMERA
		var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
		var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
		camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
		scene.add(camera);
		camera.position.set(0,-150,-750);
		camera.lookAt(scene.position);	

		// RENDERER
		if ( Detector.webgl )
			renderer = new THREE.WebGLRenderer( {antialias:true} );
		else
			renderer = new THREE.CanvasRenderer();

		renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.body.appendChild( renderer.domElement );
		container = document.getElementById( 'ThreeJS' );
		container.appendChild( renderer.domElement );

		renderer.shadowMapEnabled	= true;
		renderer.shadowMapType 		= THREE.PCFSoftShadowMap;

		// EVENTS
		THREEx.WindowResize(renderer, camera);
		THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });

		// CONTROLS
		controls = new THREE.OrbitControls( camera, renderer.domElement );

		// STATS
		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.bottom = '0px';
		stats.domElement.style.zIndex = 100;
		// container.appendChild( stats.domElement );

		// LIGHT
		var light	= new THREE.DirectionalLight( 0x777777, 2 );
		light.position.set( 75,1250,-750 ).normalize();  
		scene.add( light );

		//SHADOW
		var spotLight	= new THREE.DirectionalLight( 0x888888 );
		spotLight.position.set( 150,1500,-800 );
		spotLight.shadowCameraNear	= 0.01;	

		spotLight.shadowCameraLeft = -3000;
		spotLight.shadowCameraRight = 3000;
		spotLight.shadowCameraTop = 3500;
		spotLight.shadowCameraBottom = -3000;

		spotLight.castShadow		= true;
		spotLight.shadowDarkness	= 0.5;
		// spotLight.shadowCameraVisible	= true;
		// console.dir(spotLight)
		spotLight.shadowMapWidth	= 4096;
		spotLight.shadowMapHeight	= 4096;
		scene.add( spotLight );	
		
		// FLOOR
		var floorTexture = new THREE.ImageUtils.loadTexture( 'images/grass14.png' );
		floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
		floorTexture.repeat.set( 10, 10 );
		var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
		var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
		var floor = new THREE.Mesh(floorGeometry, floorMaterial);
		floor.position.y = -0.5;
		floor.rotation.x = Math.PI / 2;
		///scene.add(floor);

		floor.castShadow	= false;
		floor.receiveShadow	= true;
		
		// SKYBOX/FOG	
		var imagePrefix = "images/skybox_";
		var directions  = ["right", "left", "top", "bottom", "front", "back"];
		var imageSuffix = ".jpg";
		
		var materialArray = [];
		var material;
		for (var i = 0; i < 6; i++){
			material = new THREE.MeshBasicMaterial({
				map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
				side: THREE.BackSide
			});
			materialArray.push(material);
		}

		var skyBoxMaterial = new THREE.MeshFaceMaterial( materialArray );

		var fog_color = 0x9999ff; 
		var alpha = 0.00025;
		var skyBoxGeometry = new THREE.CubeGeometry( 2500, 2500, 2500 );
		// var skyBoxMaterial = new THREE.MeshBasicMaterial( { map: fog_color, side: THREE.BackSide } );
		var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );

		scene.add(skyBox);
		
		skyBox.castShadow = false
		skyBox.receiveShadow = true;
		//scene.fog = new THREE.FogExp2( fog_color, 0.0001 );
		
		////////////
		// CUSTOM //
		////////////
		
		// create an array with six textures for a cool cube
		var materialArray = [];
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/right.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/left.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/top.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/bot.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/back.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/front.png' ) }));
		var Strawberry1Mat = new THREE.MeshFaceMaterial(materialArray);
		var Strawberry1Geom = new THREE.CubeGeometry( 75, 75, 75, 1, 1, 1, materialArray );
		Strawberry1 = new THREE.Mesh( Strawberry1Geom, Strawberry1Mat );
		Strawberry1.position.set(0, 30.1, 0);
		scene.add( Strawberry1 );

		Strawberry1.castShadow = true;
		Strawberry1.receiveShadow = false;	


		var materialArray = [];
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/s_right.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/s_left.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/s_top.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/s_bot.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/s_back.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/s_front.png' ) }));
		var Strawberry2Mat = new THREE.MeshFaceMaterial(materialArray);
		var Strawberry2Geom = new THREE.CubeGeometry( 75, 75, 75, 1, 1, 1, materialArray );
		Strawberry2 = new THREE.Mesh( Strawberry2Geom, Strawberry2Mat );
		Strawberry2.position.set(150, 30.1, 0);
		scene.add( Strawberry2 );

		Strawberry2.castShadow = true;
		Strawberry2.receiveShadow = false;	
		


		var materialArray = [];
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/g_right.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/g_left.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/g_top.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/g_bot.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/g_back.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/g_front.png' ) }));
		var AppleGMat = new THREE.MeshFaceMaterial(materialArray);
		var AppleGGeom = new THREE.CubeGeometry( 75, 75, 75, 1, 1, 1, materialArray );
		AppleG = new THREE.Mesh( AppleGGeom, AppleGMat );
		AppleG.position.set(-150, 30.1, 0);
		scene.add( AppleG );

		AppleG.castShadow = true;
		AppleG.receiveShadow = false;	




		var materialArray = [];
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/w_right.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/w_left.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/w_top.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/w_bot.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/w_back.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/w_front.png' ) }));
		var WatermelonMat = new THREE.MeshFaceMaterial(materialArray);
		var WatermelonGeom = new THREE.CubeGeometry( 75, 75, 75, 1, 1, 1, materialArray );
		Watermelon = new THREE.Mesh( WatermelonGeom, WatermelonMat );
		Watermelon.position.set(-300, 30.1, 0);
		scene.add( Watermelon );

		Watermelon.castShadow = true;
		Watermelon.receiveShadow = false;	


		var materialArray = [];
		materialArray.push(new THREE.MeshPhongMaterial( { color: 0xffff00 }));
		materialArray.push(new THREE.MeshPhongMaterial( { color: 0x00ff00 }));
		materialArray.push(new THREE.MeshPhongMaterial( { color: 0x0000ff }));
		materialArray.push(new THREE.MeshPhongMaterial( { color: 0x00ffff }));
		materialArray.push(new THREE.MeshPhongMaterial( { color: 0xff00ff }));
		materialArray.push(new THREE.MeshPhongMaterial( { color: 0xff0000 }));
		var ColoredCubeMat = new THREE.MeshFaceMaterial(materialArray);
		var ColoredCubeGeom = new THREE.CubeGeometry( 75, 75, 75, 1, 1, 1, materialArray );
		ColoredCube = new THREE.Mesh( ColoredCubeGeom, ColoredCubeMat );
		ColoredCube.position.set(300, 30.1, 0);
		scene.add( ColoredCube );

		ColoredCube.castShadow = true;
		ColoredCube.receiveShadow = false;	


		var materialArray = [];
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/3_right.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/1_left.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/6_top.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/5_bot.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/4_back.png' ) }));
		materialArray.push(new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'images/2_front.png' ) }));
		var DiceMat = new THREE.MeshFaceMaterial(materialArray);
		var DiceGeom = new THREE.CubeGeometry( 75, 75, 75, 1, 1, 1, materialArray );
		Dice = new THREE.Mesh( DiceGeom, DiceMat );
		Dice.position.set(-450, 30.1, 0);
		scene.add( Dice );

		Dice.castShadow = true;
		Dice.receiveShadow = false;	
		
	}

	function onDocumentMouseMove( event ) {
			var vector = new THREE.Vector3( event.clientX - SCREEN_WIDTH_HALF, - event.clientY + SCREEN_HEIGHT_HALF, 0 );
			for ( var i = 0, il = boids.length; i < il; i++ ) {
				boid = boids[ i ];
				vector.z = boid.position.z;
				boid.repulse( vector );
			}
		}

	function animate() 
	{
		requestAnimationFrame( animate );
		render();
		stats.end();		
		update();
	}

	function update()
	{
		var delta = clock.getDelta(); // seconds.
		var moveDistance = 200 * delta; // 200 pixels per second
		var rotateAngle = Math.PI / 2 * delta;   // pi/2 radians (90 degrees) per second
		
		// local coordinates
		// local transformations

		// move forwards/backwards/left/right
		if ( keyboard.pressed("W") ){
			Strawberry1.translateZ( -moveDistance );
			Strawberry2.translateZ( -moveDistance );
			AppleG.translateZ( -moveDistance );
			Watermelon.translateZ( -moveDistance );
			ColoredCube.translateZ( -moveDistance );
			Dice.translateZ( -moveDistance );
		}
		if ( keyboard.pressed("S") ){
			Strawberry1.translateZ(  moveDistance );
			Strawberry2.translateZ(  moveDistance );
			AppleG.translateZ(  moveDistance );
			Watermelon.translateZ( moveDistance );
			ColoredCube.translateZ( moveDistance );
			Dice.translateZ( moveDistance );
		}
		if ( keyboard.pressed("Q") ){
			Strawberry1.translateX( -moveDistance );
			Strawberry2.translateX( -moveDistance );
			AppleG.translateX( -moveDistance );
			Watermelon.translateX( -moveDistance );
			ColoredCube.translateX( -moveDistance );
			Dice.translateX( -moveDistance );
		}
		if ( keyboard.pressed("E") ){
			Strawberry1.translateX(  moveDistance );
			Strawberry2.translateX(  moveDistance );
			AppleG.translateX( moveDistance );
			Watermelon.translateX( moveDistance );
			ColoredCube.translateX( moveDistance );
			Dice.translateX( moveDistance );	
		}

		// rotate left/right/up/down
		var rotation_matrix = new THREE.Matrix4().identity();
		if ( keyboard.pressed("A") ){
			Strawberry1.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
			Strawberry2.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
			AppleG.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
			Watermelon.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
			ColoredCube.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
			Dice.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
		}
		if ( keyboard.pressed("D") ){
			Strawberry1.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
			Strawberry2.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
			AppleG.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
			Watermelon.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
			ColoredCube.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
			Dice.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
		}
		if ( keyboard.pressed("R") ){
			Strawberry1.rotateOnAxis( new THREE.Vector3(1,0,0), rotateAngle);
			Strawberry2.rotateOnAxis( new THREE.Vector3(1,0,0), rotateAngle);
			AppleG.rotateOnAxis( new THREE.Vector3(1,0,0), rotateAngle);
			Watermelon.rotateOnAxis( new THREE.Vector3(1,0,0), rotateAngle);
			ColoredCube.rotateOnAxis( new THREE.Vector3(1,0,0), rotateAngle);
			Dice.rotateOnAxis( new THREE.Vector3(1,0,0), rotateAngle);			
		}
		if ( keyboard.pressed("F") ){
			Strawberry1.rotateOnAxis( new THREE.Vector3(1,0,0), -rotateAngle);
			Strawberry2.rotateOnAxis( new THREE.Vector3(1,0,0), -rotateAngle);
			AppleG.rotateOnAxis( new THREE.Vector3(1,0,0), -rotateAngle);
			Watermelon.rotateOnAxis( new THREE.Vector3(1,0,0), -rotateAngle);
			ColoredCube.rotateOnAxis( new THREE.Vector3(1,0,0), -rotateAngle);
			Dice.rotateOnAxis( new THREE.Vector3(1,0,0), -rotateAngle);
		}
		
		if ( keyboard.pressed("Z") )
		{
			Strawberry1.position.set(0,30.1,0);
			Strawberry1.rotation.set(0,0,0);

			Strawberry2.position.set(150, 30.1, 0);
			Strawberry2.rotation.set(0,0,0);

			AppleG.position.set(-150, 30.1, 0);
			AppleG.rotation.set(0,0,0);

			Watermelon.position.set(-300, 30.1, 0);
			Watermelon.rotation.set(0,0,0);

			ColoredCube.position.set(300, 30.1, 0);
			ColoredCube.rotation.set(0,0,0);

			Dice.position.set(-450, 30.1, 0);
			Dice.rotation.set(0,0,0);

		}
			
		// global coordinates
		if ( keyboard.pressed("left") ){
			ColoredCube.position.x -= moveDistance;
			Strawberry2.position.x += moveDistance;
			Strawberry1.position.x -= moveDistance;
			AppleG.position.x += moveDistance;
			Watermelon.position.x -= moveDistance;
			Dice.position.x += moveDistance;
		}
		if ( keyboard.pressed("right") ){
			ColoredCube.position.x += moveDistance;
			Strawberry2.position.x -= moveDistance;
			Strawberry1.position.x += moveDistance;
			AppleG.position.x -= moveDistance;
			Watermelon.position.x += moveDistance;
			Dice.position.x -= moveDistance;
		}
		if ( keyboard.pressed("up") ){
			ColoredCube.position.z -= moveDistance;
			Strawberry2.position.z += moveDistance;
			Strawberry1.position.z -= moveDistance;
			AppleG.position.z += moveDistance;
			Watermelon.position.z -= moveDistance;
			Dice.position.z += moveDistance;
		}
		if ( keyboard.pressed("down") ){
			ColoredCube.position.z += moveDistance;
			Strawberry2.position.z -= moveDistance;
			Strawberry1.position.z += moveDistance;
			AppleG.position.z -= moveDistance;
			Watermelon.position.z += moveDistance;
			Dice.position.z -= moveDistance;
		}
			
		controls.update();
		stats.update();
	}

	function render() 
	{
		for ( var i = 0, il = birds.length; i < il; i++ ) {
			boid = boids[ i ];
			boid.run( boids );

			bird = birds[ i ];
			bird.position.copy( boids[ i ].position );

			color = bird.material.color;
			color.r = color.g = color.b = ( 500 - bird.position.z ) / 1000;

			bird.rotation.y = Math.atan2( - boid.velocity.z, boid.velocity.x );
			bird.rotation.z = Math.asin( boid.velocity.y / boid.velocity.length() );

			bird.phase = ( bird.phase + ( Math.max( 0, bird.rotation.z ) + 0.1 )  ) % 62.83;
			bird.geometry.vertices[ 5 ].y = bird.geometry.vertices[ 4 ].y = Math.sin( bird.phase ) * 5;
		}

		// rotate the cube around its axes
		Strawberry1.rotation.y += 0.02;
		Strawberry2.rotation.y += 0.02;
		AppleG.rotation.y += 0.02;
		Watermelon.rotation.y += 0.02;

		ColoredCube.rotation.y += 0.02;
		ColoredCube.rotation.z += 0.01;
		ColoredCube.rotation.x += 0.03;
		 
		Dice.rotation.y += 0.02;
		Dice.rotation.z += 0.01;
		Dice.rotation.x += 0.03;



		// AppleG.translateY( 10 );


		renderer.render( scene, camera );

		
		
		
	}

	</script>
</body>
</html>
